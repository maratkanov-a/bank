package mock

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/maratkanov-a/bank/internal/pkg/repository"
)

// AccountRepositoryMock implements repository.AccountRepository
type AccountRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, ac *mm_repository.Account) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, ac *mm_repository.Account)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mAccountRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mAccountRepositoryMockDelete

	funcGetByID          func(ctx context.Context, id int64) (ap1 *mm_repository.Account, err error)
	inspectFuncGetByID   func(ctx context.Context, id int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mAccountRepositoryMockGetByID

	funcList          func(ctx context.Context) (apa1 []*mm_repository.Account, err error)
	inspectFuncList   func(ctx context.Context)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mAccountRepositoryMockList

	funcListByAvailability          func(ctx context.Context, isAvailable bool) (apa1 []*mm_repository.Account, err error)
	inspectFuncListByAvailability   func(ctx context.Context, isAvailable bool)
	afterListByAvailabilityCounter  uint64
	beforeListByAvailabilityCounter uint64
	ListByAvailabilityMock          mAccountRepositoryMockListByAvailability

	funcUpdate          func(ctx context.Context, ac *mm_repository.Account) (err error)
	inspectFuncUpdate   func(ctx context.Context, ac *mm_repository.Account)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mAccountRepositoryMockUpdate
}

// NewAccountRepositoryMock returns a mock for repository.AccountRepository
func NewAccountRepositoryMock(t minimock.Tester) *AccountRepositoryMock {
	m := &AccountRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mAccountRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*AccountRepositoryMockCreateParams{}

	m.DeleteMock = mAccountRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*AccountRepositoryMockDeleteParams{}

	m.GetByIDMock = mAccountRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*AccountRepositoryMockGetByIDParams{}

	m.ListMock = mAccountRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*AccountRepositoryMockListParams{}

	m.ListByAvailabilityMock = mAccountRepositoryMockListByAvailability{mock: m}
	m.ListByAvailabilityMock.callArgs = []*AccountRepositoryMockListByAvailabilityParams{}

	m.UpdateMock = mAccountRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*AccountRepositoryMockUpdateParams{}

	return m
}

type mAccountRepositoryMockCreate struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockCreateExpectation
	expectations       []*AccountRepositoryMockCreateExpectation

	callArgs []*AccountRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockCreateExpectation specifies expectation struct of the AccountRepository.Create
type AccountRepositoryMockCreateExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockCreateParams
	results *AccountRepositoryMockCreateResults
	Counter uint64
}

// AccountRepositoryMockCreateParams contains parameters of the AccountRepository.Create
type AccountRepositoryMockCreateParams struct {
	ctx context.Context
	ac  *mm_repository.Account
}

// AccountRepositoryMockCreateResults contains results of the AccountRepository.Create
type AccountRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Expect(ctx context.Context, ac *mm_repository.Account) *mAccountRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AccountRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &AccountRepositoryMockCreateParams{ctx, ac}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Inspect(f func(ctx context.Context, ac *mm_repository.Account)) *mAccountRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by AccountRepository.Create
func (mmCreate *mAccountRepositoryMockCreate) Return(i1 int64, err error) *AccountRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AccountRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &AccountRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the AccountRepository.Create method
func (mmCreate *mAccountRepositoryMockCreate) Set(f func(ctx context.Context, ac *mm_repository.Account) (i1 int64, err error)) *AccountRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the AccountRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the AccountRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the AccountRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mAccountRepositoryMockCreate) When(ctx context.Context, ac *mm_repository.Account) *AccountRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AccountRepositoryMock.Create mock is already set by Set")
	}

	expectation := &AccountRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &AccountRepositoryMockCreateParams{ctx, ac},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.Create return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockCreateExpectation) Then(i1 int64, err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements repository.AccountRepository
func (mmCreate *AccountRepositoryMock) Create(ctx context.Context, ac *mm_repository.Account) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, ac)
	}

	mm_params := &AccountRepositoryMockCreateParams{ctx, ac}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := AccountRepositoryMockCreateParams{ctx, ac}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("AccountRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the AccountRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, ac)
	}
	mmCreate.t.Fatalf("Unexpected call to AccountRepositoryMock.Create. %v %v", ctx, ac)
	return
}

// CreateAfterCounter returns a count of finished AccountRepositoryMock.Create invocations
func (mmCreate *AccountRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of AccountRepositoryMock.Create invocations
func (mmCreate *AccountRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mAccountRepositoryMockCreate) Calls() []*AccountRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.Create")
	}
}

type mAccountRepositoryMockDelete struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockDeleteExpectation
	expectations       []*AccountRepositoryMockDeleteExpectation

	callArgs []*AccountRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockDeleteExpectation specifies expectation struct of the AccountRepository.Delete
type AccountRepositoryMockDeleteExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockDeleteParams
	results *AccountRepositoryMockDeleteResults
	Counter uint64
}

// AccountRepositoryMockDeleteParams contains parameters of the AccountRepository.Delete
type AccountRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// AccountRepositoryMockDeleteResults contains results of the AccountRepository.Delete
type AccountRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for AccountRepository.Delete
func (mmDelete *mAccountRepositoryMockDelete) Expect(ctx context.Context, id int64) *mAccountRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AccountRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AccountRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &AccountRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.Delete
func (mmDelete *mAccountRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mAccountRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by AccountRepository.Delete
func (mmDelete *mAccountRepositoryMockDelete) Return(err error) *AccountRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AccountRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AccountRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &AccountRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the AccountRepository.Delete method
func (mmDelete *mAccountRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *AccountRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the AccountRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the AccountRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the AccountRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mAccountRepositoryMockDelete) When(ctx context.Context, id int64) *AccountRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AccountRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &AccountRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &AccountRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.Delete return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockDeleteExpectation) Then(err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements repository.AccountRepository
func (mmDelete *AccountRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := &AccountRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := AccountRepositoryMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("AccountRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the AccountRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to AccountRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished AccountRepositoryMock.Delete invocations
func (mmDelete *AccountRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of AccountRepositoryMock.Delete invocations
func (mmDelete *AccountRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mAccountRepositoryMockDelete) Calls() []*AccountRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.Delete")
	}
}

type mAccountRepositoryMockGetByID struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockGetByIDExpectation
	expectations       []*AccountRepositoryMockGetByIDExpectation

	callArgs []*AccountRepositoryMockGetByIDParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockGetByIDExpectation specifies expectation struct of the AccountRepository.GetByID
type AccountRepositoryMockGetByIDExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockGetByIDParams
	results *AccountRepositoryMockGetByIDResults
	Counter uint64
}

// AccountRepositoryMockGetByIDParams contains parameters of the AccountRepository.GetByID
type AccountRepositoryMockGetByIDParams struct {
	ctx context.Context
	id  int64
}

// AccountRepositoryMockGetByIDResults contains results of the AccountRepository.GetByID
type AccountRepositoryMockGetByIDResults struct {
	ap1 *mm_repository.Account
	err error
}

// Expect sets up expected params for AccountRepository.GetByID
func (mmGetByID *mAccountRepositoryMockGetByID) Expect(ctx context.Context, id int64) *mAccountRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("AccountRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &AccountRepositoryMockGetByIDExpectation{}
	}

	mmGetByID.defaultExpectation.params = &AccountRepositoryMockGetByIDParams{ctx, id}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.GetByID
func (mmGetByID *mAccountRepositoryMockGetByID) Inspect(f func(ctx context.Context, id int64)) *mAccountRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by AccountRepository.GetByID
func (mmGetByID *mAccountRepositoryMockGetByID) Return(ap1 *mm_repository.Account, err error) *AccountRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("AccountRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &AccountRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &AccountRepositoryMockGetByIDResults{ap1, err}
	return mmGetByID.mock
}

//Set uses given function f to mock the AccountRepository.GetByID method
func (mmGetByID *mAccountRepositoryMockGetByID) Set(f func(ctx context.Context, id int64) (ap1 *mm_repository.Account, err error)) *AccountRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the AccountRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the AccountRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the AccountRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mAccountRepositoryMockGetByID) When(ctx context.Context, id int64) *AccountRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("AccountRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &AccountRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &AccountRepositoryMockGetByIDParams{ctx, id},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockGetByIDExpectation) Then(ap1 *mm_repository.Account, err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockGetByIDResults{ap1, err}
	return e.mock
}

// GetByID implements repository.AccountRepository
func (mmGetByID *AccountRepositoryMock) GetByID(ctx context.Context, id int64) (ap1 *mm_repository.Account, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := &AccountRepositoryMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_got := AccountRepositoryMockGetByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("AccountRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the AccountRepositoryMock.GetByID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to AccountRepositoryMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished AccountRepositoryMock.GetByID invocations
func (mmGetByID *AccountRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of AccountRepositoryMock.GetByID invocations
func (mmGetByID *AccountRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mAccountRepositoryMockGetByID) Calls() []*AccountRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.GetByID")
	}
}

type mAccountRepositoryMockList struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockListExpectation
	expectations       []*AccountRepositoryMockListExpectation

	callArgs []*AccountRepositoryMockListParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockListExpectation specifies expectation struct of the AccountRepository.List
type AccountRepositoryMockListExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockListParams
	results *AccountRepositoryMockListResults
	Counter uint64
}

// AccountRepositoryMockListParams contains parameters of the AccountRepository.List
type AccountRepositoryMockListParams struct {
	ctx context.Context
}

// AccountRepositoryMockListResults contains results of the AccountRepository.List
type AccountRepositoryMockListResults struct {
	apa1 []*mm_repository.Account
	err  error
}

// Expect sets up expected params for AccountRepository.List
func (mmList *mAccountRepositoryMockList) Expect(ctx context.Context) *mAccountRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("AccountRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &AccountRepositoryMockListExpectation{}
	}

	mmList.defaultExpectation.params = &AccountRepositoryMockListParams{ctx}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.List
func (mmList *mAccountRepositoryMockList) Inspect(f func(ctx context.Context)) *mAccountRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by AccountRepository.List
func (mmList *mAccountRepositoryMockList) Return(apa1 []*mm_repository.Account, err error) *AccountRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("AccountRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &AccountRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &AccountRepositoryMockListResults{apa1, err}
	return mmList.mock
}

//Set uses given function f to mock the AccountRepository.List method
func (mmList *mAccountRepositoryMockList) Set(f func(ctx context.Context) (apa1 []*mm_repository.Account, err error)) *AccountRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the AccountRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the AccountRepository.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the AccountRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mAccountRepositoryMockList) When(ctx context.Context) *AccountRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("AccountRepositoryMock.List mock is already set by Set")
	}

	expectation := &AccountRepositoryMockListExpectation{
		mock:   mmList.mock,
		params: &AccountRepositoryMockListParams{ctx},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.List return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockListExpectation) Then(apa1 []*mm_repository.Account, err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockListResults{apa1, err}
	return e.mock
}

// List implements repository.AccountRepository
func (mmList *AccountRepositoryMock) List(ctx context.Context) (apa1 []*mm_repository.Account, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx)
	}

	mm_params := &AccountRepositoryMockListParams{ctx}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := AccountRepositoryMockListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("AccountRepositoryMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the AccountRepositoryMock.List")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx)
	}
	mmList.t.Fatalf("Unexpected call to AccountRepositoryMock.List. %v", ctx)
	return
}

// ListAfterCounter returns a count of finished AccountRepositoryMock.List invocations
func (mmList *AccountRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of AccountRepositoryMock.List invocations
func (mmList *AccountRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mAccountRepositoryMockList) Calls() []*AccountRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.List")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.List")
	}
}

type mAccountRepositoryMockListByAvailability struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockListByAvailabilityExpectation
	expectations       []*AccountRepositoryMockListByAvailabilityExpectation

	callArgs []*AccountRepositoryMockListByAvailabilityParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockListByAvailabilityExpectation specifies expectation struct of the AccountRepository.ListByAvailability
type AccountRepositoryMockListByAvailabilityExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockListByAvailabilityParams
	results *AccountRepositoryMockListByAvailabilityResults
	Counter uint64
}

// AccountRepositoryMockListByAvailabilityParams contains parameters of the AccountRepository.ListByAvailability
type AccountRepositoryMockListByAvailabilityParams struct {
	ctx         context.Context
	isAvailable bool
}

// AccountRepositoryMockListByAvailabilityResults contains results of the AccountRepository.ListByAvailability
type AccountRepositoryMockListByAvailabilityResults struct {
	apa1 []*mm_repository.Account
	err  error
}

// Expect sets up expected params for AccountRepository.ListByAvailability
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) Expect(ctx context.Context, isAvailable bool) *mAccountRepositoryMockListByAvailability {
	if mmListByAvailability.mock.funcListByAvailability != nil {
		mmListByAvailability.mock.t.Fatalf("AccountRepositoryMock.ListByAvailability mock is already set by Set")
	}

	if mmListByAvailability.defaultExpectation == nil {
		mmListByAvailability.defaultExpectation = &AccountRepositoryMockListByAvailabilityExpectation{}
	}

	mmListByAvailability.defaultExpectation.params = &AccountRepositoryMockListByAvailabilityParams{ctx, isAvailable}
	for _, e := range mmListByAvailability.expectations {
		if minimock.Equal(e.params, mmListByAvailability.defaultExpectation.params) {
			mmListByAvailability.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListByAvailability.defaultExpectation.params)
		}
	}

	return mmListByAvailability
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.ListByAvailability
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) Inspect(f func(ctx context.Context, isAvailable bool)) *mAccountRepositoryMockListByAvailability {
	if mmListByAvailability.mock.inspectFuncListByAvailability != nil {
		mmListByAvailability.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.ListByAvailability")
	}

	mmListByAvailability.mock.inspectFuncListByAvailability = f

	return mmListByAvailability
}

// Return sets up results that will be returned by AccountRepository.ListByAvailability
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) Return(apa1 []*mm_repository.Account, err error) *AccountRepositoryMock {
	if mmListByAvailability.mock.funcListByAvailability != nil {
		mmListByAvailability.mock.t.Fatalf("AccountRepositoryMock.ListByAvailability mock is already set by Set")
	}

	if mmListByAvailability.defaultExpectation == nil {
		mmListByAvailability.defaultExpectation = &AccountRepositoryMockListByAvailabilityExpectation{mock: mmListByAvailability.mock}
	}
	mmListByAvailability.defaultExpectation.results = &AccountRepositoryMockListByAvailabilityResults{apa1, err}
	return mmListByAvailability.mock
}

//Set uses given function f to mock the AccountRepository.ListByAvailability method
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) Set(f func(ctx context.Context, isAvailable bool) (apa1 []*mm_repository.Account, err error)) *AccountRepositoryMock {
	if mmListByAvailability.defaultExpectation != nil {
		mmListByAvailability.mock.t.Fatalf("Default expectation is already set for the AccountRepository.ListByAvailability method")
	}

	if len(mmListByAvailability.expectations) > 0 {
		mmListByAvailability.mock.t.Fatalf("Some expectations are already set for the AccountRepository.ListByAvailability method")
	}

	mmListByAvailability.mock.funcListByAvailability = f
	return mmListByAvailability.mock
}

// When sets expectation for the AccountRepository.ListByAvailability which will trigger the result defined by the following
// Then helper
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) When(ctx context.Context, isAvailable bool) *AccountRepositoryMockListByAvailabilityExpectation {
	if mmListByAvailability.mock.funcListByAvailability != nil {
		mmListByAvailability.mock.t.Fatalf("AccountRepositoryMock.ListByAvailability mock is already set by Set")
	}

	expectation := &AccountRepositoryMockListByAvailabilityExpectation{
		mock:   mmListByAvailability.mock,
		params: &AccountRepositoryMockListByAvailabilityParams{ctx, isAvailable},
	}
	mmListByAvailability.expectations = append(mmListByAvailability.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.ListByAvailability return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockListByAvailabilityExpectation) Then(apa1 []*mm_repository.Account, err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockListByAvailabilityResults{apa1, err}
	return e.mock
}

// ListByAvailability implements repository.AccountRepository
func (mmListByAvailability *AccountRepositoryMock) ListByAvailability(ctx context.Context, isAvailable bool) (apa1 []*mm_repository.Account, err error) {
	mm_atomic.AddUint64(&mmListByAvailability.beforeListByAvailabilityCounter, 1)
	defer mm_atomic.AddUint64(&mmListByAvailability.afterListByAvailabilityCounter, 1)

	if mmListByAvailability.inspectFuncListByAvailability != nil {
		mmListByAvailability.inspectFuncListByAvailability(ctx, isAvailable)
	}

	mm_params := &AccountRepositoryMockListByAvailabilityParams{ctx, isAvailable}

	// Record call args
	mmListByAvailability.ListByAvailabilityMock.mutex.Lock()
	mmListByAvailability.ListByAvailabilityMock.callArgs = append(mmListByAvailability.ListByAvailabilityMock.callArgs, mm_params)
	mmListByAvailability.ListByAvailabilityMock.mutex.Unlock()

	for _, e := range mmListByAvailability.ListByAvailabilityMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmListByAvailability.ListByAvailabilityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListByAvailability.ListByAvailabilityMock.defaultExpectation.Counter, 1)
		mm_want := mmListByAvailability.ListByAvailabilityMock.defaultExpectation.params
		mm_got := AccountRepositoryMockListByAvailabilityParams{ctx, isAvailable}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListByAvailability.t.Errorf("AccountRepositoryMock.ListByAvailability got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListByAvailability.ListByAvailabilityMock.defaultExpectation.results
		if mm_results == nil {
			mmListByAvailability.t.Fatal("No results are set for the AccountRepositoryMock.ListByAvailability")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmListByAvailability.funcListByAvailability != nil {
		return mmListByAvailability.funcListByAvailability(ctx, isAvailable)
	}
	mmListByAvailability.t.Fatalf("Unexpected call to AccountRepositoryMock.ListByAvailability. %v %v", ctx, isAvailable)
	return
}

// ListByAvailabilityAfterCounter returns a count of finished AccountRepositoryMock.ListByAvailability invocations
func (mmListByAvailability *AccountRepositoryMock) ListByAvailabilityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListByAvailability.afterListByAvailabilityCounter)
}

// ListByAvailabilityBeforeCounter returns a count of AccountRepositoryMock.ListByAvailability invocations
func (mmListByAvailability *AccountRepositoryMock) ListByAvailabilityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListByAvailability.beforeListByAvailabilityCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.ListByAvailability.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListByAvailability *mAccountRepositoryMockListByAvailability) Calls() []*AccountRepositoryMockListByAvailabilityParams {
	mmListByAvailability.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockListByAvailabilityParams, len(mmListByAvailability.callArgs))
	copy(argCopy, mmListByAvailability.callArgs)

	mmListByAvailability.mutex.RUnlock()

	return argCopy
}

// MinimockListByAvailabilityDone returns true if the count of the ListByAvailability invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockListByAvailabilityDone() bool {
	for _, e := range m.ListByAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListByAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListByAvailabilityCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListByAvailability != nil && mm_atomic.LoadUint64(&m.afterListByAvailabilityCounter) < 1 {
		return false
	}
	return true
}

// MinimockListByAvailabilityInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockListByAvailabilityInspect() {
	for _, e := range m.ListByAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.ListByAvailability with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListByAvailabilityMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListByAvailabilityCounter) < 1 {
		if m.ListByAvailabilityMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.ListByAvailability")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.ListByAvailability with params: %#v", *m.ListByAvailabilityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListByAvailability != nil && mm_atomic.LoadUint64(&m.afterListByAvailabilityCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.ListByAvailability")
	}
}

type mAccountRepositoryMockUpdate struct {
	mock               *AccountRepositoryMock
	defaultExpectation *AccountRepositoryMockUpdateExpectation
	expectations       []*AccountRepositoryMockUpdateExpectation

	callArgs []*AccountRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// AccountRepositoryMockUpdateExpectation specifies expectation struct of the AccountRepository.Update
type AccountRepositoryMockUpdateExpectation struct {
	mock    *AccountRepositoryMock
	params  *AccountRepositoryMockUpdateParams
	results *AccountRepositoryMockUpdateResults
	Counter uint64
}

// AccountRepositoryMockUpdateParams contains parameters of the AccountRepository.Update
type AccountRepositoryMockUpdateParams struct {
	ctx context.Context
	ac  *mm_repository.Account
}

// AccountRepositoryMockUpdateResults contains results of the AccountRepository.Update
type AccountRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Expect(ctx context.Context, ac *mm_repository.Account) *mAccountRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AccountRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &AccountRepositoryMockUpdateParams{ctx, ac}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Inspect(f func(ctx context.Context, ac *mm_repository.Account)) *mAccountRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for AccountRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by AccountRepository.Update
func (mmUpdate *mAccountRepositoryMockUpdate) Return(err error) *AccountRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AccountRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &AccountRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the AccountRepository.Update method
func (mmUpdate *mAccountRepositoryMockUpdate) Set(f func(ctx context.Context, ac *mm_repository.Account) (err error)) *AccountRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the AccountRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the AccountRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the AccountRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mAccountRepositoryMockUpdate) When(ctx context.Context, ac *mm_repository.Account) *AccountRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AccountRepositoryMock.Update mock is already set by Set")
	}

	expectation := &AccountRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &AccountRepositoryMockUpdateParams{ctx, ac},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up AccountRepository.Update return parameters for the expectation previously defined by the When method
func (e *AccountRepositoryMockUpdateExpectation) Then(err error) *AccountRepositoryMock {
	e.results = &AccountRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements repository.AccountRepository
func (mmUpdate *AccountRepositoryMock) Update(ctx context.Context, ac *mm_repository.Account) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, ac)
	}

	mm_params := &AccountRepositoryMockUpdateParams{ctx, ac}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := AccountRepositoryMockUpdateParams{ctx, ac}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("AccountRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the AccountRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, ac)
	}
	mmUpdate.t.Fatalf("Unexpected call to AccountRepositoryMock.Update. %v %v", ctx, ac)
	return
}

// UpdateAfterCounter returns a count of finished AccountRepositoryMock.Update invocations
func (mmUpdate *AccountRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of AccountRepositoryMock.Update invocations
func (mmUpdate *AccountRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to AccountRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mAccountRepositoryMockUpdate) Calls() []*AccountRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*AccountRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *AccountRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *AccountRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccountRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccountRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to AccountRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to AccountRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccountRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetByIDInspect()

		m.MinimockListInspect()

		m.MinimockListByAvailabilityInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccountRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccountRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockListDone() &&
		m.MinimockListByAvailabilityDone() &&
		m.MinimockUpdateDone()
}
