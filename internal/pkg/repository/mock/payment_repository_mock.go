package mock

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/maratkanov-a/bank/internal/pkg/repository"
)

// PaymentRepositoryMock implements repository.PaymentRepository
type PaymentRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, from int64, to int64, amount int64)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPaymentRepositoryMockCreate

	funcGetByID          func(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error)
	inspectFuncGetByID   func(ctx context.Context, id int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mPaymentRepositoryMockGetByID

	funcList          func(ctx context.Context) (ppa1 []*mm_repository.Payment, err error)
	inspectFuncList   func(ctx context.Context)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mPaymentRepositoryMockList
}

// NewPaymentRepositoryMock returns a mock for repository.PaymentRepository
func NewPaymentRepositoryMock(t minimock.Tester) *PaymentRepositoryMock {
	m := &PaymentRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPaymentRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*PaymentRepositoryMockCreateParams{}

	m.GetByIDMock = mPaymentRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*PaymentRepositoryMockGetByIDParams{}

	m.ListMock = mPaymentRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*PaymentRepositoryMockListParams{}

	return m
}

type mPaymentRepositoryMockCreate struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockCreateExpectation
	expectations       []*PaymentRepositoryMockCreateExpectation

	callArgs []*PaymentRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockCreateExpectation specifies expectation struct of the PaymentRepository.Create
type PaymentRepositoryMockCreateExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockCreateParams
	results *PaymentRepositoryMockCreateResults
	Counter uint64
}

// PaymentRepositoryMockCreateParams contains parameters of the PaymentRepository.Create
type PaymentRepositoryMockCreateParams struct {
	ctx    context.Context
	from   int64
	to     int64
	amount int64
}

// PaymentRepositoryMockCreateResults contains results of the PaymentRepository.Create
type PaymentRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Expect(ctx context.Context, from int64, to int64, amount int64) *mPaymentRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &PaymentRepositoryMockCreateParams{ctx, from, to, amount}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Inspect(f func(ctx context.Context, from int64, to int64, amount int64)) *mPaymentRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Return(i1 int64, err error) *PaymentRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &PaymentRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the PaymentRepository.Create method
func (mmCreate *mPaymentRepositoryMockCreate) Set(f func(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error)) *PaymentRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the PaymentRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPaymentRepositoryMockCreate) When(ctx context.Context, from int64, to int64, amount int64) *PaymentRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &PaymentRepositoryMockCreateParams{ctx, from, to, amount},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.Create return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockCreateExpectation) Then(i1 int64, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements repository.PaymentRepository
func (mmCreate *PaymentRepositoryMock) Create(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, from, to, amount)
	}

	mm_params := &PaymentRepositoryMockCreateParams{ctx, from, to, amount}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockCreateParams{ctx, from, to, amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PaymentRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the PaymentRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, from, to, amount)
	}
	mmCreate.t.Fatalf("Unexpected call to PaymentRepositoryMock.Create. %v %v %v %v", ctx, from, to, amount)
	return
}

// CreateAfterCounter returns a count of finished PaymentRepositoryMock.Create invocations
func (mmCreate *PaymentRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PaymentRepositoryMock.Create invocations
func (mmCreate *PaymentRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPaymentRepositoryMockCreate) Calls() []*PaymentRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.Create")
	}
}

type mPaymentRepositoryMockGetByID struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockGetByIDExpectation
	expectations       []*PaymentRepositoryMockGetByIDExpectation

	callArgs []*PaymentRepositoryMockGetByIDParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockGetByIDExpectation specifies expectation struct of the PaymentRepository.GetByID
type PaymentRepositoryMockGetByIDExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockGetByIDParams
	results *PaymentRepositoryMockGetByIDResults
	Counter uint64
}

// PaymentRepositoryMockGetByIDParams contains parameters of the PaymentRepository.GetByID
type PaymentRepositoryMockGetByIDParams struct {
	ctx context.Context
	id  int64
}

// PaymentRepositoryMockGetByIDResults contains results of the PaymentRepository.GetByID
type PaymentRepositoryMockGetByIDResults struct {
	pp1 *mm_repository.Payment
	err error
}

// Expect sets up expected params for PaymentRepository.GetByID
func (mmGetByID *mPaymentRepositoryMockGetByID) Expect(ctx context.Context, id int64) *mPaymentRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PaymentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PaymentRepositoryMockGetByIDExpectation{}
	}

	mmGetByID.defaultExpectation.params = &PaymentRepositoryMockGetByIDParams{ctx, id}
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.GetByID
func (mmGetByID *mPaymentRepositoryMockGetByID) Inspect(f func(ctx context.Context, id int64)) *mPaymentRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by PaymentRepository.GetByID
func (mmGetByID *mPaymentRepositoryMockGetByID) Return(pp1 *mm_repository.Payment, err error) *PaymentRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PaymentRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &PaymentRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &PaymentRepositoryMockGetByIDResults{pp1, err}
	return mmGetByID.mock
}

//Set uses given function f to mock the PaymentRepository.GetByID method
func (mmGetByID *mPaymentRepositoryMockGetByID) Set(f func(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error)) *PaymentRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	return mmGetByID.mock
}

// When sets expectation for the PaymentRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mPaymentRepositoryMockGetByID) When(ctx context.Context, id int64) *PaymentRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("PaymentRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockGetByIDExpectation{
		mock:   mmGetByID.mock,
		params: &PaymentRepositoryMockGetByIDParams{ctx, id},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockGetByIDExpectation) Then(pp1 *mm_repository.Payment, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockGetByIDResults{pp1, err}
	return e.mock
}

// GetByID implements repository.PaymentRepository
func (mmGetByID *PaymentRepositoryMock) GetByID(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := &PaymentRepositoryMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockGetByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("PaymentRepositoryMock.GetByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the PaymentRepositoryMock.GetByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to PaymentRepositoryMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished PaymentRepositoryMock.GetByID invocations
func (mmGetByID *PaymentRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of PaymentRepositoryMock.GetByID invocations
func (mmGetByID *PaymentRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mPaymentRepositoryMockGetByID) Calls() []*PaymentRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockGetByIDDone() bool {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.GetByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.GetByID")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.GetByID with params: %#v", *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && mm_atomic.LoadUint64(&m.afterGetByIDCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.GetByID")
	}
}

type mPaymentRepositoryMockList struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockListExpectation
	expectations       []*PaymentRepositoryMockListExpectation

	callArgs []*PaymentRepositoryMockListParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockListExpectation specifies expectation struct of the PaymentRepository.List
type PaymentRepositoryMockListExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockListParams
	results *PaymentRepositoryMockListResults
	Counter uint64
}

// PaymentRepositoryMockListParams contains parameters of the PaymentRepository.List
type PaymentRepositoryMockListParams struct {
	ctx context.Context
}

// PaymentRepositoryMockListResults contains results of the PaymentRepository.List
type PaymentRepositoryMockListResults struct {
	ppa1 []*mm_repository.Payment
	err  error
}

// Expect sets up expected params for PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Expect(ctx context.Context) *mPaymentRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PaymentRepositoryMockListExpectation{}
	}

	mmList.defaultExpectation.params = &PaymentRepositoryMockListParams{ctx}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Inspect(f func(ctx context.Context)) *mPaymentRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Return(ppa1 []*mm_repository.Payment, err error) *PaymentRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PaymentRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &PaymentRepositoryMockListResults{ppa1, err}
	return mmList.mock
}

//Set uses given function f to mock the PaymentRepository.List method
func (mmList *mPaymentRepositoryMockList) Set(f func(ctx context.Context) (ppa1 []*mm_repository.Payment, err error)) *PaymentRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the PaymentRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mPaymentRepositoryMockList) When(ctx context.Context) *PaymentRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockListExpectation{
		mock:   mmList.mock,
		params: &PaymentRepositoryMockListParams{ctx},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.List return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockListExpectation) Then(ppa1 []*mm_repository.Payment, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockListResults{ppa1, err}
	return e.mock
}

// List implements repository.PaymentRepository
func (mmList *PaymentRepositoryMock) List(ctx context.Context) (ppa1 []*mm_repository.Payment, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx)
	}

	mm_params := &PaymentRepositoryMockListParams{ctx}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("PaymentRepositoryMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the PaymentRepositoryMock.List")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx)
	}
	mmList.t.Fatalf("Unexpected call to PaymentRepositoryMock.List. %v", ctx)
	return
}

// ListAfterCounter returns a count of finished PaymentRepositoryMock.List invocations
func (mmList *PaymentRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of PaymentRepositoryMock.List invocations
func (mmList *PaymentRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mPaymentRepositoryMockList) Calls() []*PaymentRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.List")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.List")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockGetByIDInspect()

		m.MinimockListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockListDone()
}
