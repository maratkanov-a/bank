package mock

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/maratkanov-a/bank/internal/pkg/repository"
)

// PaymentRepositoryMock implements repository.PaymentRepository
type PaymentRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, from int64, to int64, amount int64)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPaymentRepositoryMockCreate

	funcGetByIDMock          func(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error)
	inspectFuncGetByIDMock   func(ctx context.Context, id int64)
	afterGetByIDMockCounter  uint64
	beforeGetByIDMockCounter uint64
	GetByIDMockMock          mPaymentRepositoryMockGetByIDMock

	funcList          func(ctx context.Context) (ppa1 []*mm_repository.Payment, err error)
	inspectFuncList   func(ctx context.Context)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mPaymentRepositoryMockList
}

// NewPaymentRepositoryMock returns a mock for repository.PaymentRepository
func NewPaymentRepositoryMock(t minimock.Tester) *PaymentRepositoryMock {
	m := &PaymentRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPaymentRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*PaymentRepositoryMockCreateParams{}

	m.GetByIDMockMock = mPaymentRepositoryMockGetByIDMock{mock: m}
	m.GetByIDMockMock.callArgs = []*PaymentRepositoryMockGetByIDMockParams{}

	m.ListMock = mPaymentRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*PaymentRepositoryMockListParams{}

	return m
}

type mPaymentRepositoryMockCreate struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockCreateExpectation
	expectations       []*PaymentRepositoryMockCreateExpectation

	callArgs []*PaymentRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockCreateExpectation specifies expectation struct of the PaymentRepository.Create
type PaymentRepositoryMockCreateExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockCreateParams
	results *PaymentRepositoryMockCreateResults
	Counter uint64
}

// PaymentRepositoryMockCreateParams contains parameters of the PaymentRepository.Create
type PaymentRepositoryMockCreateParams struct {
	ctx    context.Context
	from   int64
	to     int64
	amount int64
}

// PaymentRepositoryMockCreateResults contains results of the PaymentRepository.Create
type PaymentRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Expect(ctx context.Context, from int64, to int64, amount int64) *mPaymentRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &PaymentRepositoryMockCreateParams{ctx, from, to, amount}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Inspect(f func(ctx context.Context, from int64, to int64, amount int64)) *mPaymentRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by PaymentRepository.Create
func (mmCreate *mPaymentRepositoryMockCreate) Return(i1 int64, err error) *PaymentRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &PaymentRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the PaymentRepository.Create method
func (mmCreate *mPaymentRepositoryMockCreate) Set(f func(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error)) *PaymentRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the PaymentRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPaymentRepositoryMockCreate) When(ctx context.Context, from int64, to int64, amount int64) *PaymentRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentRepositoryMock.Create mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &PaymentRepositoryMockCreateParams{ctx, from, to, amount},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.Create return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockCreateExpectation) Then(i1 int64, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements repository.PaymentRepository
func (mmCreate *PaymentRepositoryMock) Create(ctx context.Context, from int64, to int64, amount int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, from, to, amount)
	}

	mm_params := &PaymentRepositoryMockCreateParams{ctx, from, to, amount}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockCreateParams{ctx, from, to, amount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PaymentRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the PaymentRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, from, to, amount)
	}
	mmCreate.t.Fatalf("Unexpected call to PaymentRepositoryMock.Create. %v %v %v %v", ctx, from, to, amount)
	return
}

// CreateAfterCounter returns a count of finished PaymentRepositoryMock.Create invocations
func (mmCreate *PaymentRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PaymentRepositoryMock.Create invocations
func (mmCreate *PaymentRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPaymentRepositoryMockCreate) Calls() []*PaymentRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.Create")
	}
}

type mPaymentRepositoryMockGetByIDMock struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockGetByIDMockExpectation
	expectations       []*PaymentRepositoryMockGetByIDMockExpectation

	callArgs []*PaymentRepositoryMockGetByIDMockParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockGetByIDMockExpectation specifies expectation struct of the PaymentRepository.GetByIDMock
type PaymentRepositoryMockGetByIDMockExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockGetByIDMockParams
	results *PaymentRepositoryMockGetByIDMockResults
	Counter uint64
}

// PaymentRepositoryMockGetByIDMockParams contains parameters of the PaymentRepository.GetByIDMock
type PaymentRepositoryMockGetByIDMockParams struct {
	ctx context.Context
	id  int64
}

// PaymentRepositoryMockGetByIDMockResults contains results of the PaymentRepository.GetByIDMock
type PaymentRepositoryMockGetByIDMockResults struct {
	pp1 *mm_repository.Payment
	err error
}

// Expect sets up expected params for PaymentRepository.GetByIDMock
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) Expect(ctx context.Context, id int64) *mPaymentRepositoryMockGetByIDMock {
	if mmGetByIDMock.mock.funcGetByIDMock != nil {
		mmGetByIDMock.mock.t.Fatalf("PaymentRepositoryMock.GetByIDMock mock is already set by Set")
	}

	if mmGetByIDMock.defaultExpectation == nil {
		mmGetByIDMock.defaultExpectation = &PaymentRepositoryMockGetByIDMockExpectation{}
	}

	mmGetByIDMock.defaultExpectation.params = &PaymentRepositoryMockGetByIDMockParams{ctx, id}
	for _, e := range mmGetByIDMock.expectations {
		if minimock.Equal(e.params, mmGetByIDMock.defaultExpectation.params) {
			mmGetByIDMock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByIDMock.defaultExpectation.params)
		}
	}

	return mmGetByIDMock
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.GetByIDMock
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) Inspect(f func(ctx context.Context, id int64)) *mPaymentRepositoryMockGetByIDMock {
	if mmGetByIDMock.mock.inspectFuncGetByIDMock != nil {
		mmGetByIDMock.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.GetByIDMock")
	}

	mmGetByIDMock.mock.inspectFuncGetByIDMock = f

	return mmGetByIDMock
}

// Return sets up results that will be returned by PaymentRepository.GetByIDMock
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) Return(pp1 *mm_repository.Payment, err error) *PaymentRepositoryMock {
	if mmGetByIDMock.mock.funcGetByIDMock != nil {
		mmGetByIDMock.mock.t.Fatalf("PaymentRepositoryMock.GetByIDMock mock is already set by Set")
	}

	if mmGetByIDMock.defaultExpectation == nil {
		mmGetByIDMock.defaultExpectation = &PaymentRepositoryMockGetByIDMockExpectation{mock: mmGetByIDMock.mock}
	}
	mmGetByIDMock.defaultExpectation.results = &PaymentRepositoryMockGetByIDMockResults{pp1, err}
	return mmGetByIDMock.mock
}

//Set uses given function f to mock the PaymentRepository.GetByIDMock method
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) Set(f func(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error)) *PaymentRepositoryMock {
	if mmGetByIDMock.defaultExpectation != nil {
		mmGetByIDMock.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.GetByIDMock method")
	}

	if len(mmGetByIDMock.expectations) > 0 {
		mmGetByIDMock.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.GetByIDMock method")
	}

	mmGetByIDMock.mock.funcGetByIDMock = f
	return mmGetByIDMock.mock
}

// When sets expectation for the PaymentRepository.GetByIDMock which will trigger the result defined by the following
// Then helper
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) When(ctx context.Context, id int64) *PaymentRepositoryMockGetByIDMockExpectation {
	if mmGetByIDMock.mock.funcGetByIDMock != nil {
		mmGetByIDMock.mock.t.Fatalf("PaymentRepositoryMock.GetByIDMock mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockGetByIDMockExpectation{
		mock:   mmGetByIDMock.mock,
		params: &PaymentRepositoryMockGetByIDMockParams{ctx, id},
	}
	mmGetByIDMock.expectations = append(mmGetByIDMock.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.GetByIDMock return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockGetByIDMockExpectation) Then(pp1 *mm_repository.Payment, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockGetByIDMockResults{pp1, err}
	return e.mock
}

// GetByIDMock implements repository.PaymentRepository
func (mmGetByIDMock *PaymentRepositoryMock) GetByIDMock(ctx context.Context, id int64) (pp1 *mm_repository.Payment, err error) {
	mm_atomic.AddUint64(&mmGetByIDMock.beforeGetByIDMockCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByIDMock.afterGetByIDMockCounter, 1)

	if mmGetByIDMock.inspectFuncGetByIDMock != nil {
		mmGetByIDMock.inspectFuncGetByIDMock(ctx, id)
	}

	mm_params := &PaymentRepositoryMockGetByIDMockParams{ctx, id}

	// Record call args
	mmGetByIDMock.GetByIDMockMock.mutex.Lock()
	mmGetByIDMock.GetByIDMockMock.callArgs = append(mmGetByIDMock.GetByIDMockMock.callArgs, mm_params)
	mmGetByIDMock.GetByIDMockMock.mutex.Unlock()

	for _, e := range mmGetByIDMock.GetByIDMockMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetByIDMock.GetByIDMockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByIDMock.GetByIDMockMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByIDMock.GetByIDMockMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockGetByIDMockParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByIDMock.t.Errorf("PaymentRepositoryMock.GetByIDMock got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByIDMock.GetByIDMockMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByIDMock.t.Fatal("No results are set for the PaymentRepositoryMock.GetByIDMock")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetByIDMock.funcGetByIDMock != nil {
		return mmGetByIDMock.funcGetByIDMock(ctx, id)
	}
	mmGetByIDMock.t.Fatalf("Unexpected call to PaymentRepositoryMock.GetByIDMock. %v %v", ctx, id)
	return
}

// GetByIDMockAfterCounter returns a count of finished PaymentRepositoryMock.GetByIDMock invocations
func (mmGetByIDMock *PaymentRepositoryMock) GetByIDMockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDMock.afterGetByIDMockCounter)
}

// GetByIDMockBeforeCounter returns a count of PaymentRepositoryMock.GetByIDMock invocations
func (mmGetByIDMock *PaymentRepositoryMock) GetByIDMockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByIDMock.beforeGetByIDMockCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.GetByIDMock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByIDMock *mPaymentRepositoryMockGetByIDMock) Calls() []*PaymentRepositoryMockGetByIDMockParams {
	mmGetByIDMock.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockGetByIDMockParams, len(mmGetByIDMock.callArgs))
	copy(argCopy, mmGetByIDMock.callArgs)

	mmGetByIDMock.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDMockDone returns true if the count of the GetByIDMock invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockGetByIDMockDone() bool {
	for _, e := range m.GetByIDMockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDMockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByIDMock != nil && mm_atomic.LoadUint64(&m.afterGetByIDMockCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByIDMockInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockGetByIDMockInspect() {
	for _, e := range m.GetByIDMockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.GetByIDMock with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByIDMockCounter) < 1 {
		if m.GetByIDMockMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.GetByIDMock")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.GetByIDMock with params: %#v", *m.GetByIDMockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByIDMock != nil && mm_atomic.LoadUint64(&m.afterGetByIDMockCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.GetByIDMock")
	}
}

type mPaymentRepositoryMockList struct {
	mock               *PaymentRepositoryMock
	defaultExpectation *PaymentRepositoryMockListExpectation
	expectations       []*PaymentRepositoryMockListExpectation

	callArgs []*PaymentRepositoryMockListParams
	mutex    sync.RWMutex
}

// PaymentRepositoryMockListExpectation specifies expectation struct of the PaymentRepository.List
type PaymentRepositoryMockListExpectation struct {
	mock    *PaymentRepositoryMock
	params  *PaymentRepositoryMockListParams
	results *PaymentRepositoryMockListResults
	Counter uint64
}

// PaymentRepositoryMockListParams contains parameters of the PaymentRepository.List
type PaymentRepositoryMockListParams struct {
	ctx context.Context
}

// PaymentRepositoryMockListResults contains results of the PaymentRepository.List
type PaymentRepositoryMockListResults struct {
	ppa1 []*mm_repository.Payment
	err  error
}

// Expect sets up expected params for PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Expect(ctx context.Context) *mPaymentRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PaymentRepositoryMockListExpectation{}
	}

	mmList.defaultExpectation.params = &PaymentRepositoryMockListParams{ctx}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Inspect(f func(ctx context.Context)) *mPaymentRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for PaymentRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by PaymentRepository.List
func (mmList *mPaymentRepositoryMockList) Return(ppa1 []*mm_repository.Payment, err error) *PaymentRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &PaymentRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &PaymentRepositoryMockListResults{ppa1, err}
	return mmList.mock
}

//Set uses given function f to mock the PaymentRepository.List method
func (mmList *mPaymentRepositoryMockList) Set(f func(ctx context.Context) (ppa1 []*mm_repository.Payment, err error)) *PaymentRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the PaymentRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the PaymentRepository.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the PaymentRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mPaymentRepositoryMockList) When(ctx context.Context) *PaymentRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("PaymentRepositoryMock.List mock is already set by Set")
	}

	expectation := &PaymentRepositoryMockListExpectation{
		mock:   mmList.mock,
		params: &PaymentRepositoryMockListParams{ctx},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up PaymentRepository.List return parameters for the expectation previously defined by the When method
func (e *PaymentRepositoryMockListExpectation) Then(ppa1 []*mm_repository.Payment, err error) *PaymentRepositoryMock {
	e.results = &PaymentRepositoryMockListResults{ppa1, err}
	return e.mock
}

// List implements repository.PaymentRepository
func (mmList *PaymentRepositoryMock) List(ctx context.Context) (ppa1 []*mm_repository.Payment, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx)
	}

	mm_params := &PaymentRepositoryMockListParams{ctx}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := PaymentRepositoryMockListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("PaymentRepositoryMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the PaymentRepositoryMock.List")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx)
	}
	mmList.t.Fatalf("Unexpected call to PaymentRepositoryMock.List. %v", ctx)
	return
}

// ListAfterCounter returns a count of finished PaymentRepositoryMock.List invocations
func (mmList *PaymentRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of PaymentRepositoryMock.List invocations
func (mmList *PaymentRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to PaymentRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mPaymentRepositoryMockList) Calls() []*PaymentRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*PaymentRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *PaymentRepositoryMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *PaymentRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentRepositoryMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PaymentRepositoryMock.List")
		} else {
			m.t.Errorf("Expected call to PaymentRepositoryMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to PaymentRepositoryMock.List")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockGetByIDMockInspect()

		m.MinimockListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIDMockDone() &&
		m.MinimockListDone()
}
